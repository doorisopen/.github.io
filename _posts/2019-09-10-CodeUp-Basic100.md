---
layout: post
title:  "[CodeUp] 기초 100제"
date:   2019-09-10 00:36:59
author: me
categories: Ps
tags:	Problem Solving Ps Algorithm C++
cover:  "/assets/instacode.png"
---

__19/06/26__
<br />
<br />


>> __CodeUp 기초 100제를 풀면서 헷갈리는 내용 정리한 내용__


<br />
<br />

<hr />

### 1019 연월일 입력받아 형식에 맞게 출력하기
 입력 : 2012.02.15 <br />
 출력 : 2012.02.15. <br />
* __Tip__
scanf(“%d”,&a); <br />
printf(“%d”,a); <br />
 %d   -> 2 <br />
 %02d -> 02 <br />
 %04d -> 0002 <br />

<hr />

### 1022 문장 한 개 입력받아 그대로 출력하기
 입력 : C++ programming is very fun!! <br />
 출력 : C++ programming is very fun!! <br />
* __Tip__

```
char data[2001] 
// 키보드(stdin)로 입력 받아 최대 2000 문자(영문자)까지 data[] 공간에 저장하고 출력할 수 있다. 한글의 경우 1000글자까지 가능
fgets(data,2000,stdin);
printf(“%s”, data);
```

<hr />

### 1025 정수 한 개 입력받아 나누어 출력하기
 입력 : 75254 <br />
 출력 : [70000] <br />
[5000] <br />
[200] <br />
[50] <br />
[4] <br />

* __코드__

```
#include <cstdio>
#pragma warning(disable: 4996)
int main() {
	int a, b, i=10000;
	scanf("%d",&a);
	while(i>0){
		b = (a / i)*i; // ex) (75254/10000)*10000
		printf("\[%d\]\n", b);
		a = a – b; // 75254 - 70000
		i = i / 10; // i = 10000 / 10
	}
	return 0;
}
```

<hr />

### 1028 정수 한 개 입력받아 그대로 출력하기2 : unsigned int
 int a (정수)의 범위 -> -2147483648 ~ +2147483647 <br />
 printf(“%d or %i”,a); <br />

 unsigned int a -> 0 ~ 4294967295 <br />
 scanf(“%u”,&a); <br />
 printf(“%u”,a); <br />

<hr />

### 1029 실수 한 개 입력받아 그대로 출력하기2 : float&double
 float a -> 3.4*10^-38 ~ 3.4*10^38 <br />
 double a -> 1.7*10^-308 ~ 1.7*10^308 <br />

<hr />

### 1030 정수 한 개 입력받아 그대로 출력하기3 : long long int
long long int a -> –9,223,372,036,854,775,808 ~ 9,223,372,036,854,775,807 <br />

scanf("%lld", &a); <br />
printf("%lld", a); <br />

<hr />

### 1047 비트 시프트연산 : 정수 한 개 입력받아 2 곱해 출력하기

```
// 입력 : 1024
// 출력 : 2048
int a = 10
printf(“%d”,a<<1); // 20 출력
printf(“%d”,a>>1); // 5 출력
printf(“%d”,a<<2); // 2번 시프트 40 출력
printf(“%d”,a>>2); // 2 출력
```

<hr />

### 1059 : 비트단위로 바꿔 출력하기
비트단위(bitwise) 연산자 <br />
.~ (bitwise not), <br />
.& (bitwise and), <br />
.| (bitwise or), <br />
.^ (bitwise xor), <br />
.<< (bitwise left shift), <br />
.>> (bitwise right shift) <br />
* __Tip__
1 (32비트 2진수로 표현하면 00000000 00000000 00000000 0000001) 이 입력되었을 때,  <br />
~1은 -2(11111111 11111111 11111111 11111110) 가 된다. <br />
음의 정수의 "2의 보수 표현" 방법 <br />
예를 들어 int형(4바이트(byte), 32비트)으로 선언된 변수에 양의 정수 5를 저장하면 <br />

5의 2진수 형태인 101이 32비트로 만들어져 <br />

00000000 00000000 00000000 00000101  <br />
로 저장된다.(공백은 보기 편하도록 임의로 분리) <br />

int 형의 정수 0은 <br />
00000000 00000000 00000000 00000000 <br />

그리고, -1은 0에서 1을 더 빼고 32비트만 표시하는 형태로 <br />
11111111 11111111 11111111 11111111 <br />
로 저장된다. <br />

-2는? -1에서 1을 더 빼면 된다. <br />
11111111 11111111 11111111 11111110 <br />
로 저장된다.  <br />

그래서... <br />
int 형으로 선언된 변수에는  <br />

최소 <br />
-2147483648 을 의미하는  <br />
10000000 00000000 00000000 00000000 <br />
부터 <br />

최대 <br />
+2147483647 을 의미하는 <br />
01111111 11111111 11111111 11111111 <br />
로 저장될 수 있는 것이다. <br />

그렇다면... <br />
-2147483648 <br />
10000000 00000000 00000000 00000000 <br />
에서 1을 더 뺀다면? <br />

01111111 11111111 11111111 11111111 <br />
이 된다. 즉 -2147483649 가 아닌 +2147483647이 되는 것이다. <br />

이러한 것을 오버플로우(overflow, 넘침)이라고 한다. <br />

한편, 이러한 내용을 간단히 표시하면 <br />

정수 n이라고 할 때, <br />

~n = -n - 1<br />
-n = ~n + 1 과 같은 관계로 표현된다.<br />

*& (bitwise and)<br />
 3 : 00000000 00000000 00000000 00000011<br />
 5 : 00000000 00000000 00000000 00000101<br />
3&5 : 00000000 00000000 00000000 00000001<br />
*| (bitwise or)<br />
 3 : 00000000 00000000 00000000 0000011<br />
 5 : 00000000 00000000 00000000 0000101<br />
 3|5 : 00000000 00000000 00000000 0000111<br />
*^ (bitwise xor)<br />
 3 : 00000000 00000000 00000000 00000011<br />
 5 : 00000000 00000000 00000000 00000101<br />
 3^5 : 00000000 00000000 00000000 00000110<br />

<hr />

### 1071 0 입력될 때까지 무한 출력하기1
* __goto 명령문__
goto 이름:<br />
명령은 이름: 이 작성된 곳으로 프로그램의 실행 흐름을 바꾸어 준다.<br />
이름: 과 같이 콜론(:)이 붙어있는 부분을 이름표(label, 레이블/라벨)라고 한다.<br />
레이블은 특별한 선언 없이 사용할 수 있으며 언더바(_)나 영문자로 시작하면 된다.<br />
goto 레이블;<br />
명령을 사용하면 반복되는 부분을 여러 개 자유롭게 만들 수 있다.<br />
goto 명령은 반복실행을 만들어낼 수 있는 가장 간단한 명령이지만,<br />
복잡하게 사용하는 경우, 이해가 어렵고 오류가 생기기 쉽니다.  스파게티코드라고도 한다.<br />
* __예시__

```
int n;
reload:                    //레이블은 콜론( : ) 으로 끝난다. 
scanf("%d", &n);
printf("%d", n);
if(n!=0) goto reload; 	//reload라고 적혀있는 레이블로 실행 이동
```
