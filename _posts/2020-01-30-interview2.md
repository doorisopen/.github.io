---
layout: post
title:  "서버 개발 면접 대비"
date:   2020-01-30 15:30:30
author: me
categories: Interview
tags:	Interview Web Jsp Spring Java DB Server
cover:  "/assets/instacode.png"
---


앞으로 다가올 서버 개발자 면접을 위해 예상 질문 리스트를 만들어 보았다

질문 리스트는 나의 자소서 내용 중심으로 질문지가 구성 될 것이다


# [질문 리스트]
## 1. __웹 3계층__ 이 어떻게 동작하는지 설명하세요.

3계층 구조란 `프레젠테이션 로직(클라이언트, 사용자 인터페이스), 비즈니스 로직, 데이터베이스 로직`을 각각 다른 플랫폼 상에서 구현한 것이다. 3계층 구조에서 각 계층은 물리적으로도 독립적이며 각 계층의 변경이 다른 계층에 의존하지 않는다.

* __`프레젠테이션(클라이언트) 계층`__

프레젠테이션 계층은 응용 프로그램의 최상위에 위치하고 있는데 이는 서로 다른 층에 있는 데이터 등과 커뮤니케이션을 한다.
- 사용자 인터페이스를 지원한다. (인터넷 브라우저의 정적인 데이터를 제공한다.)    
- 이 계층은 GUI, 또는front-end도 불린다.
- 비즈니스로직이나 데이터관리코드를 포함해서는 안된다.
- 주로 웹서버를 뜻한다(물리적 : WEB서버)
ex) HTML, javascript, CSS, image

    

* __`애플리케이션 계층`__

이 계층은 비즈니스 로직 계층 또는 트랜잭션 계층이라고도 하는데, 비즈니스 로직은 워크스테이션으로부터의 클라이언트 요청에 대해 마치 서버처럼 행동한다. 차례로 어떤 데이터가 필요한지를 결정하고, 메인프레임 컴퓨터 상에 위치하고 있을 세 번째 계층의 프로그램에 대해서는 마치 클라이언트처럼 행동한다.

- 정보처리의 규칙을 가지고 있다.(동적인 데이터를 제공한다)
- middleware 또는 back-end로 불린다.
- 프레젠테이션코드나 데이터관리 코드를 포함해서는 안된다.
- 주로 어플리케이션 서버를 뜻한다(물리적 : WAS서버)

ex) Java EE, ASP.NET, PHP

* __`데이터 계층`__

데이터 계층은 데이터베이스와 그것에 액세스해서 읽거나 쓰는 것을 관리하는 프로그램을 포함한다. 애플리케이션의 조직은 이것보다 더욱 복잡해질 수 있지만, 3계층 관점은 대규모 프로그램에서 일부분에 관해 생각하기에 편리한 방법이다.

- 데이터베이스를 주로 뜻한다.
- DB 또는 File System를 접근 및 관리한다.
- back-end라고도 불린다.
- 주로 DB서버를 뜻한다(물리적 : DB서버)

ex) MySQL DB, Oracle DB

<hr/>

## 2. __웹 서버__ 와 __WAS__ 의 각각의 특징과 차이점을 설명하세요.

### 웹 서버
* __`웹 서버의 개념`__
  + 웹 서버는 소프트웨어와 하드웨어로 구분된다.
  + __1) 하드웨어__
    - Web 서버가 설치되어있는 컴퓨터
  + __2) 소프트웨어__
    - 웹 브라우저 클라이언트로부터 HTTP 요청을 받아 정적인 컨텐츠(.html .jpeg .css 등)를 제공하는 컴퓨터 프로그램

* __`웹 서버의 기능`__
  + __HTTP 프로토콜을 기반으로 하여 클라이언트(웹 브라우저 또는 웹 크롤러)의 요청을 서비스 하는 기능__ 을 담당한다.
  + __기능 1)__
    - 정적인 컨텐츠 제공
    - WAS를 거치지 않고 바로 자원을 제공한다.
  + __기능 2)__
    - 동적인 컨텐츠 제공을 위한 요청 전달
    - 클라이언트의 요청(Request)을 WAS에 보내고, WAS가 처리한 결과를 클라이언트에게 전달(응답, Response)한다.
    - 클라이언트는 일반적으로 웹 브라우저를 의미한다.

* __`웹 서버의 예`__

Ex) Apache Server, Nginx, IIS(Windows 전용 Web 서버) 등

### WAS(Web Application Server)
* __`WAS(Web Application Server)의 개념`__
  + DB 조회나 다양한 로직 처리를 요구하는 동적인 컨텐츠를 제공하기 위해 만들어진 Application Server
  + HTTP를 통해 컴퓨터나 장치에 애플리케이션을 수행해주는 미들웨어(소프트웨어 엔진)이다.
  + "웹 컨테이너(Web Container)" 혹은 "서블릿 컨테이너(Servlet Container)"라고도 불린다.
    - Container란 JSP, Servlet을 실행시킬 수 있는 소프트웨어를 말한다. 즉, WAS는 JSP, Servlet 구동 환경을 제공한다.

* __`WAS의 역할`__
  + __WAS = Web Server  + Web Container__
  + 웹 서버 기능들을 구조적으로 분리하여 처리하고자하는 목적으로 제시되었다.
    - 분산 트랜잭션, 보안, 메시징, 쓰레드 처리 등의 기능을 처리하는 분산 환경에서 사용된다.
    - 주로 DB 서버와 같이 수행된다.
  + 현재는 WAS가 가지고 있는 웹 서버 도 __정적인 컨텐츠를 처리__ 하는 데 있어서 성능상 큰 차이가 없다.

* __`WAS의 주요 기능`__
  + 프로그램 실행 환경과 DB 접속 기능 제공
  + 여러 개의 트랜잭션(논리적인 작업 단위) 관리 기능
  + 업무를 처리하는 비즈니스 로직 수행

* __`WAS의 예`__

Ex) Tomcat, JBoss, Jeus, Web Sphere 등

### 웹 서버와 WAS를 구분하는 이유
* __웹 서버 가 필요한 이유?__
  + 클라이언트(웹 브라우저)에 이미지 파일(정적 컨텐츠)을 보내는 과정을 생각해보자.
    - 이미지 파일과 같은 정적인 파일들은 웹 문서(HTML 문서)가 클라이언트로 보내질 때 함께 가는 것이 아니다.
    - 클라이언트는 HTML 문서를 먼저 받고 그에 맞게 필요한 이미지 파일들을 다시 서버로 요청하면 그때서야 이미지 파일을 받아온다.
    - 웹 서버 를 통해 정적인 파일들을 Application Server까지 가지 않고 앞단에서 빠르게 보내줄 수 있다.
  + 따라서 __웹 서버 에서는 정적 컨텐츠만 처리하도록 기능을 분배하여 서버의 부담을 줄일 수 있다.__

* __WAS가 필요한 이유?__
  + 웹 페이지는 __정적 컨텐츠__ 와 __동적 컨텐츠__ 가 모두 존재한다.
    - 사용자의 요청에 맞게 적절한 동적 컨텐츠를 만들어서 제공해야 한다.
    - 이때, __웹 서버 만을 이용한다면 사용자가 원하는 요청에 대한 결과값을 모두 미리 만들어 놓고 서비스를 해야 한다.__
    - 하지만 이렇게 수행하기에는 __자원이 절대적으로 부족__ 하다.
  + 따라서 WAS를 통해 요청에 맞는 데이터를 DB에서 가져와서 비즈니스 로직에 맞게 그때 그때 결과를 만들어서 제공함으로써 __자원을 효율적으로 사용__ 할 수 있다.

* __그렇다면 WAS가 웹 서버 의 기능도 모두 수행하면 되지 않을까?__
  + __1) 기능을 분리하여 서버 부하 방지__
    - WAS는 DB 조회나 다양한 로직을 처리하느라 바쁘기 때문에 단순한 __정적 컨텐츠는 웹 서버__ 에서 빠르게 클라이언트에 제공하는 것이 좋다.
    - __WAS는 기본적으로 동적 컨텐츠를 제공__ 하기 위해 존재하는 서버이다.
    - 만약 정적 컨텐츠 요청까지 WAS가 처리한다면 정적 데이터 처리로 인해 부하가 커지게 되고, 동적 컨텐츠의 처리가 지연됨에 따라 수행 속도가 느려진다.
    - 즉, 이로 인해 페이지 노출 시간이 늘어나게 될 것이다.

  + __2) 물리적으로 분리하여 보안 강화__
    - SSL에 대한 암복호화 처리에 __웹 서버__ 를 사용

  + __3) 여러 대의 WAS를 연결 가능__
    - Load Balancing을 위해서 __웹 서버__ 를 사용
    - fail over(장애 극복), fail back 처리에 유리
    - 특히 대용량 웹 어플리케이션의 경우(여러 개의 서버 사용) 웹 서버 와 WAS를 분리하여 무중단 운영을 위한 장애 극복에 쉽게 대응할 수 있다.
    - 예를 들어, 앞 단의 웹 서버 에서 오류가 발생한 WAS를 이용하지 못하도록 한 후 WAS를 재시작함으로써 사용자는 오류를 느끼지 못하고 이용할 수 있다.

  + __4) 여러 웹 어플리케이션 서비스 가능__
    - 예를 들어, 하나의 서버에서 PHP Application과 Java Application을 함께 사용하는 경우

  + __5) 기타__
    - 접근 허용 IP 관리, 2대 이상의 서버에서의 세션 관리 등도 웹 서버 에서 처리하면 효율적이다.

* 즉, 자원 이용의 효율성 및 장애 극복, 배포 및 유지보수의 편의성 을 위해 웹 서버 와 WAS를 분리한다.
* __웹 서버 를 WAS 앞에 두고 필요한 WAS들을 웹 서버 에 플러그인 형태로 설정하면 더욱 효율적인 분산 처리가 가능하다.__

<hr/>

## 3. 웹 서버 내부 구동 방식에 대해 설명할 수 있는가?
__웹 서버__ 는 클라이언트가 특정 페이지를 요청(Request)에 대해 처리한 후 결과를 클라이언트(웹 브라우저)에게 응답(Response)을 한다.

<hr/>

## 4. Servlet과 JSP의 차이점
* __Servlet__ : 자바 언어로 웹 개발을 위해 만들어진 것으로, Container가 이해할 수 있게 구성된 순수 자바코드로만 이루어진 것
* __JSP__ : html 기반에 JAVA 코드를 블록화하여 삽입한 것으로 Servlet을 좀 더 쉽게 접근할 수 있도록 만들어 진 것

<hr/>

## 5. MVC 패턴이란?
* __Model__ : data 처리와 접근을 담당
* __View__ : Client에 보여지는 화면을 담당
* __Controller__ : Model과 View를 제어

하는 3가지 부분으로 나눔으로서, 데이터와 화면간의 의존관계를 벗어날 수 있게하는 개발 기법입니다.

<hr/>

## 6. SpringFramework & Spring MVC & SpringBoot에 대해 설명하시오
* __SpringFramework__

__스프링 프레임워크__ 의 가장 중요한 특징은 `의존성 주입(Dependency Injection)` 이다. 모든 스프링 모듈들의 핵심에는 의존성 주입 이나 `IOC(Inversion of Control)` 가 있다.

이것이 중요한 이유는 DI나 IOC를 적절히 사용하면 우리는 느슨하게 결합된 애플리케이션들을 개발할 수 있기 때문이다. 또한 느슨하게 결합된 애플리케이션들은 단위테스트를 하기가 쉽다.

* __SpringMVC__

__Spring MVC__ 는 Dispatcher Servlet, ModelAndView, View Resolver 과 같은 단순개념을 이용해서 웹 애플리케이션 개발을 쉽게 할 수 있도록 해준다. 즉 Spring MVC는 말 그대로 MVC 구현을 할 수 있도록 지원해주는 스프링 프레임워크 이다.

* __SpringBoot__

__SpringBoot__ 는 Spring에서 제공하는 많은 라이브러리들을 기본 설정 값으로 __자동__ 으로 설정할 수 있도록 해준다. 따라서, Spring Boot는 Spring MVC를 편하게 사용할 수 있도록 해준다는 것 이다.

또한, Spring Boot 는 SpringMVC, Jackson, Validation 등 다양한 종속성들을 각각 패키지해 놓은 것을 함께 가져오기 때문에 개발자들은 이것들의 __호환버전에 대해 걱정할 필요가 없다.__


<hr/>


## 7. Request 전송 방식에는 어떤 것들이 있는지 아시나요?
* __Get 방식__ : URL의 쿼리문자열에 데이터를 같이 전달하는 방식으로 데이터 길이에 제한이 있고, 보안에 취약하다.
* __POST 방식__ : 헤더에 데이터를 넣어 보내기 때문에 보안에 조금 더 유리하고 데이터 길이에 제한이 없다. 하지만, Get에 비해 다소 느리다.
* __DELETE 방식__ : RESTFUL에서 삭제 기능을 할 때 주로 사용된다.
* __PUT/PUSH 방식__ : RESTFUL에서 수정 작업을 할 때 주로 사용된다.

<hr/>

## 8. RESTFUL이란?
해당 URL만 보더라도 바로 어떤 작업을 하는지를 알 수 있도록 하나의 데이터는 하나의 URL을 갖도록 작업하는 방식

<hr/>

## 9. Spring에서 DI란?
__DI__ 는 Dependency Injection(의존성 주입)의 약자로, 객체들 간의 의존성을 줄이기 위해 사용되는 Spring의 `IOC 컨테이너`의 구체적인 구현 방식입니다. 

DI는 기존처럼 개발코드 부분에서 객체를 생성(Ex. new wellcomeService())하는 것이 아니라, 팩토리 패턴처럼 객체의 생성과, 데이터를 주입만 담당하는 Factory에 해당 하는 별도의 공간에서 객체를 생성하고 데이터간의 의존성을 주입해 개발코드에서는 이를 가져다 씀으로서 의존성을 줄이는 방식입니다.

이때, Factory 패턴의 Factory Class의 역할을 스프링의 환경설정 파일이 담당합니다.


<hr/>

## 10. Spring의 AOP란? 그리고 AOP와 interceptor 차이는 무엇인가?
### AOP란?
__AOP__ 는 Aspect Oriented Programming 관점 지향 프로그래밍의 약자로, 기존의 OOP(객체 지향 프로그래밍)에서 기능별로 class를 분리했음에도 불구하고, 여전히 `로그`, `트랜잭션`, `자원해제`, `성능테스트 메서드` 처럼 __공통적 으로 반복되는 중복코드가 여전히 발생하는 단점을 해결하고자 나온 방식입니다.__

이러한 __공통 코드__ 를 `"횡단 관심사"`라 표현하며 개발코드에서는 비지니스 로직에 집중하고 실행시에 비지니스 로직 앞, 뒤 등 원하는 지점에 해당 공통 관심사를 수행할 수 있게 함으로서 중복 코드를 줄일 수 있는 방식입니다.

### AOP와 interceptor 차이
__AOP__: AOP는 `joinPoint`, `preceedingJoinpoint` 등의 파라미터를 활용하는 방식이다.

__interceptor__: 인터셉터의 파라미터가 `HttpServletRequest`, `HttpServletResponse` 이다.

<hr/>

## 11. SQL Mapper와 ORM의 차이
__Persistence Framework__ 는 SQL Mapper와 ORM으로 나눌 수 있다.

* ORM은 데이터베이스 __객체를 자바 객체로 매핑__ 함으로써 객체 간의 관계를 바탕으로 SQL을 자동으로 생성해주지만 SQL Mapper는 SQL을 명시해줘야 한다.
* __ORM__ 은 관계형 데이터베이스의 __"관계"를 Object에 반영__ 하자는 것이 목적이라면, __SQL Mapper__ 는 단순히 __필드를 매핑__ 시키는 것이 목적이라는 점에서 __지향점의 차이__ 가 있다.

### SQL Mapper
* SQL <—매핑—> Object 필드
* SQL Mapper는 SQL 문장으로 직접 데이터베이스 데이터를 다룬다.
  + 즉, SQL Mapper는 SQL을 명시해줘야 한다.
  + Ex) Mybatis, JdbcTempletes 등

### ORM(Object-Relational Mapping), 객체-관계 매핑
* 데이터베이스 데이터 <—매핑—> Object 필드
  + 객체를 통해 간접적으로 데이터베이스 데이터를 다룬다.
* 객체와 관계형 데이터베이스의 데이터를 자동으로 매핑(연결)해주는 것을 말한다.
  + ORM을 이용하면 SQL Query가 아닌 직관적인 코드(메서드)로 데이터를 조작할 수 있다.
  + 객체 간의 관계를 바탕으로 SQL을 자동으로 생성한다.
* Persistant API라고도 할 수 있다.

Ex) JPA, Hibernate 등

#### __장점__
  + __객체 지향적인 코드로 인해 더 직관적이고 비즈니스 로직에 더 집중할 수 있게 도와준다.__
    - 선언문, 할당, 종료 같은 부수적인 코드가 없거나 급격히 줄어든다.
    - 각종 객체에 대한 코드를 별도로 작성하기 때문에 코드의 가독성을 올려준다.
    - SQL의 절차적이고 순차적인 접근이 아닌 객체 지향적인 접근으로 인해 생산성이 증가한다.
  + __재사용 및 유지보수의 편리성이 증가한다.__
    - ORM은 독립적으로 작성되어있고, 해당 객체들을 재활용 할 수 있다.
    - 때문에 모델에서 가공된 데이터를 컨트롤러에 의해 뷰와 합쳐지는 형태로 디자인 패턴을 견고하게 다지는데 유리하다.
    - 매핑정보가 명확하여, ERD를 보는 것에 대한 의존도를 낮출 수 있다.
  + __DBMS에 대한 종속성이 줄어든다.__
    - 대부분 ORM 솔루션은 DB에 종속적이지 않다.
    - 종속적이지 않다는것은 구현 방법 뿐만아니라 많은 솔루션에서 자료형 타입까지 유효하다.
    - 프로그래머는 Object에 집중함으로 극단적으로 DBMS를 교체하는 거대한 작업에도 비교적 적은 리스크와 시간이 소요된다.
    - 또한 자바에서 가공할경우 equals, hashCode의 오버라이드 같은 자바의 기능을 이용할 수 있고, 간결하고 빠른 가공이 가능하다.

#### __단점__
  + __완벽한 ORM 으로만 서비스를 구현하기가 어렵다.__
    - 사용하기는 편하지만 설계는 매우 신중하게 해야한다.
    - 프로젝트의 복잡성이 커질경우 난이도 또한 올라갈 수 있다.
    - 잘못 구현된 경우에 속도 저하 및 심각할 경우 일관성이 무너지는 문제점이 생길 수 있다.
    - 일부 자주 사용되는 대형 쿼리는 속도를 위해 SP를 쓰는등 별도의 튜닝이 필요한 경우가 있다.
    - DBMS의 고유 기능을 이용하기 어렵다. (하지만 이건 단점으로만 볼 수 없다 : 특정 DBMS의 고유기능을 이용하면 이식성이 저하된다.)
  + __프로시저가 많은 시스템에선 ORM의 객체 지향적인 장점을 활용하기 어렵다.__
    - 이미 프로시저가 많은 시스템에선 다시 객체로 바꿔야하며, 그 과정에서 생산성 저하나 리스크가 많이 발생할 수 있다.
<hr/>

## 12. JDBC는 무엇인가?
* __Java Data Base Connection__ 의 약자로 JAVA 언어를 통해 데이터 베이스에 접근 할 수 있도록 Java에서 제공하는 API이다.
  + 모든 Java의 Data Access 기술의 근간
  + 즉, 모든 Persistence Framework는 내부적으로 JDBC API를 이용한다.
* JDBC는 데이터베이스에서 자료를 쿼리하거나 업데이트하는 방법을 제공한다.

<hr/>

## 13. Spring에서 MyBatis는 무엇인지 아시나요?
* 개발자가 지정한 SQL, 저장 프로시저 그리고 몇 가지 고급 매핑을 지원하는 __SQL Mapper__ 이다.
* __JDBC로 처리하는 상당 부분의 코드와 파라미터 설정 및 결과 매핑을 대신해준다.__
  + 기존에 JDBC를 사용할 때는 DB와 관련된 여러 __복잡한 설정(Connection)__ 들을 다루어야 했지만 SQL Mapper는 자바 객체를 실제 SQL문에 연결함으로써, 빠른 개발과 편리한 테스트 환경을 제공한다.
* 데이터베이스 record에 원시 타입과 Map 인터페이스 그리고 자바 POJO를 설정해서 매핑하기 위해 xml과 Annotation을 사용할 수 있다.
* MyBatis는 원래 Apache Foundation의 iBatis였으나, 생산성, 개발 프로세스, 커뮤니티 등의 이유로 Google Code로 이전되면서 이름이 바뀌었다.
  + iBatis와 바뀐 차이점은 아래와 같다.
    - JDK 1.5, Annotation
    - Dynatic SQL, XML Element
* __장점__
  + SQL에 대한 모든 컨트롤을 하고자 할때 매우 적합하다.
  + SQL쿼리들이 매우 잘 최적화되어 있을 때에 유용하다.
* __단점__
  + 애플리케이션과 데이터베이스 간의 설계에 대한 모든 조작을 하고자 할 때는 적합하지 않다.
    - 애플리케이션과 데이터베이스 간에 서로 잘 구조화되도록 많은 설정이 바뀌어야 하기 때문이다.

<hr/>

## 14. JPA/Hibernate는 무엇인가?
### JPA
* 자바 ORM 기술에 대한 API 표준 명세로, Java에서 제공하는 API이다.
  + 자바 플랫폼 SE와 자바 플랫폼 EE를 사용하는 응용프로그램에서 __관계형 데이터베이스의 관리를 표현하는 자바 API이다.__
  + 즉, JPA는 __ORM을 사용하기 위한 표준 인터페이스를 모아둔 것__ 이다.
  + 기존에 EJB에서 제공되던 __엔터티 빈(Entity Bean)을 대체하는 기술__ 이다.
* __JPA 구성 요소__
  + `javax.persistance` 패키지로 정의된 API 그 자체
  + JPQL(Java Persistence Query Language)
  + 객체/관계 메타데이터
* 사용자가 원하는 JPA 구현체를 선택해서 사용할 수 있다.
  + JPA의 대표적인 구현체로는 `Hibernate`, EclipseLink, DataNucleus, OpenJPA, TopLink Essentials 등이 있다.
  + 이 구현체들을 `ORM Framework`라고 부른다.

### Hibernate
* Hibernate는 __JPA의 구현체 중 하나__ 이다.
* Hibernate가 SQL을 직접 사용하지 않는다고 해서 JDBC API를 사용하지 않는다는 것은 아니다.
  + Hibernate가 지원하는 메서드 내부에서는 JDBC API가 동작하고 있으며, 단지 개발자가 직접 SQL을 직접 작성하지 않을 뿐이다.
* __HQL(Hibernate Query Language)__ 이라 불리는 매우 강력한 __쿼리 언어를 포함__ 하고 있다.
  + HQL은 SQL과 매우 비슷하며 추가적인 컨벤션을 정의할 수도 있다.
  + HQL은 완전히 객체 지향적이며 이로써 상속, 다형성, 관계등의 객체지향의 강점을 누릴 수 있다.
  + HQL쿼리는 자바 클래스와 프로퍼티의 이름을 제외하고는 대소문자를 구분한다.
  + HQL은 쿼리 결과로 객체를 반환하며 프로그래머에 의해 생성되고 직접적으로 접근할 수 있다.
  + HQL은 SQL에서는 지원하지 않는 페이지네이션이나 동적 프로파일링과 같은 향상된 기능을 제공한다.
  + HQL은 여러 테이블을 작업할 때 명시적인 join을 요구하지 않는다.
* __장점__
  + 객체지향적으로 데이터를 관리할 수 있기 때문에 비즈니스 로직에 집중 할 수 있으며, 객체지향 개발이 가능하다.
  + 테이블 생성, 변경, 관리가 쉽다. (JPA를 잘 이해하고 있는 경우)
  + 로직을 쿼리에 집중하기 보다는 객체자체에 집중 할 수 있다.
  + 빠른 개발이 가능하다.
* __단점__
  + 어렵다. (많은 내용이 감싸져 있기 때문에 알아야 할 것이 많다.)
  + 잘 이해하고 사용하지 않으면 데이터 손실이 있을 수 있다. (persistence context)
  + 성능상 문제가 있을 수 있다. (이 문제 또한 잘 이해해야 해결이 가능하다.)

<hr/>

## 15. Maven과 Gradle의 차이점
* __Maven은__ Build라는 동적인 요소를 XML로 정의하기에는 어려운 부분이 많다.
  + 설정 내용이 길어지고 __가독성__ 떨어짐
  + 의존관계가 __복잡한 프로젝트 설정하기에 부적절__
  + 상속구조를 이용한 멀티 모듈 구현
  + 특정 설정을 소수의 모듈에서 공유하기 위해서는 부모 프로젝트를 생성하여 상속하게 해야 함 (상속의 단점 생김)
* __Gradle은__ Groovy를 사용하기 때문에, 동적인 빌드는 Groovy 스크립트로 플러그인을 호출하거나 직접 코드를 짜면 된다.
  + Configuration Injection 방식을 사용해서 공통 모듈을 상속해서 사용하는 단점을 커버했다.
  + 설정 주입 시 프로젝트의 조건을 체크할 수 있어서 프로젝트별로 주입되는 설정을 다르게 할 수 있다.

<hr/>

## 16. Filter와 Interceptor 방식의 차이?
`영역 제어 측면`에서의 차이가 있는다. __Filter__ 는 웹 어플리케이션내에서 동작하므로, 스프링의 context 접근이 어렵다. __Interceptor__ 는 스프링의 context 내에 존재하므로 context내의 모든 객체를 활용할 수 있다.

<hr/>

## 17. 디자인 패턴 아는 것?
* 클래스 인스턴스가 하나만 만들어지도록 하고, 그 인스턴스에 대한 전역 접근을 제공한다.

__1. 싱글톤(SingleTone Pattern)__ : 대표적으로 Calendar 객체나 dataSource 객체처럼 객체가 하나만 생성되어야 하는 경우 전체 코드에서 하나의 객체만 존재할 수 있도록 이미 생성된 객체가 있으면 그 객체를 사용하도록 하는 방식입니다.

__2. 팩토리 패턴(Factory pattern)__ : 객체간 의존성을 줄이기 위해 객체의 생성과 데이터 주입만 담당하는 Factory Class를 정의하고 개발 코드 부분에서는 생성된 객체를 가져다 사용함으로서 의존성을 줄이는 방식입니다.

__3. 옵저버 패턴(Observer Pattern)__ : 기후 정보처럼 RSS 수신시 하나의 객체가 변하면 다른 객체에 객체가 변했다는 사항을 알려주어야 할 경우에 주로 사용됩니다.

<hr/>

## 18. 프로젝트 개발 순서??
1. 요구사항 분석 기획 및 스토리 보드 작성
2. WBS(Work Breakdown Structure) 작성: 작업 분해도로 프로젝트 범위와 최종산출물을 세부요소로 분할한 계층적 구조도
4. 논리 ERD 작성
5. 물리 ERD 작성
6. 개발
7. Testing
8. 유지보수

<hr/>

## 19. 스프링의 MVC에 대해서 설명하시오.
1. __클라이언트__ ---Request-> __서버__
2. 스프링에서 제공하는 __DispatcherServlet__ 이라는 클래스(일종의 frontController)가 요청을 가로챈다.
3. DispatcherServlet은 __HandlerMapping__ (URL 분석 등)에게 어떤 컨트롤러에 요청을 위임하면 좋은지 물어본다. (servlet-context.xml에서 @Controller로 등록한 것들을 스캔해서 찾음)
4. 요청에 매핑된 컨트롤러가 있으면 @RequestMapping을 통하여 요청을 처리할 메서드에 도달한다.
5. 컨트롤러는 해당 요청을 처리할 Service DI받아 비즈니스로직을 Service에 위임한다.
6. Service는 요청에 필요한 비즈니스로직을 처리, DB접근이 필요하면 DAO를 DI받아 DB처리는 DAO에 위임.
7. DAO는 myBatis(or Hibernate등) 설정을 이용해서 SQL 쿼리를 날려 DB의 정보를 받아 Service에 리턴. (보통 쿼리 결과는 DTO(VO)에 담는다)
8. __DAO__ ---Return-> __Service__ ---Return-> __Controller__
9. Controller는 Model객체에 결과물 어떤 view(jsp)파일을 보여줄 것인지등의 정보를 담아 DispatcherServlet에게 보낸다.
10. DispatcherServlet은 __ViewResolver에게 받은 뷰의 대한 정보__ 를 넘긴다.
11. ViewResolver는 해당 __JSP를 찾아서(응답할 View를 찾음) DispatcherServlet__ 에게 알려준다.
(servlet-context.xml에서 suffix, prefix를 통해 /WEB-INF/views/index.jsp 이렇게 만들어주는 것도 ViewResolver)
12. DispatcherServlet은 응답할 View에게 Render를 지시하고 View는 응답 로직을 처리한다.
13. 결과적으로 DispatcherServlet이 클라이언트에게 렌더링된 View를 응답한다.

#### 흐름 요약
* __Request__
> Client --> Server --> DispatcherServlet(HandlerMapping) --> Controller --> Service --> DAO
* __Response__
> DAO --> Service --> Controller --> DispatcherServlet(ViewResolver) --> View(Render) --> Client

<hr/>

## 20. "애자일" 방법론에 대해서 아는가?
간단히 말하면 __애자일__ 이란 `협력`과 `피드백`을 자주, 일찍, 더 잘하는 것을 의미한다

### __애자일의 핵심1. "협력"__
* SW 프로젝트가 망하는 경우는 기술 외적인 것도 크다. 따라서 특히 SW 개발의 불확실성이 높을 때는 `"협력"` 을 잘 해야한다.

* 혼자 얻은 좋은 통찰을 협력을 통해 다른 사람도 같이 얻을 수 있다.
* 예상하지 못했던 기회를 잡을 수 있다.


* 문제가 되는 것을 찾기가 쉽다.
* 예상하지 못했던 문제를 협력이 막을 수 있다.


### __애자일의 핵심2. "피드백"__
* `피드백`은 학습의 가장 큰 전제조건이다. 내가 어떻게 했는가를 확인하면서 학습해야 한다.
* 또한, SW 개발의 불확실성이 높을수록 `학습` 이 중요해진다. 왜냐하면 모르는 것이 많기 때문에 더 빨리 배워나가야하기 때문이다.
* 일을 잘하는 사람은 `feedback seeking` 이 뛰어나다. 즉, 이런 사람들은 더 자주 더 많은 사람들에게 피드백을 구한다.

* __내부적 피드백__
  + 내가 만든 것이 어떻게 됐는지 확인해보는 것
* __외부적 피드백__
  + 내가 만든 것을 고객이나 다른 부서가 사용해보고 그것을 통해 또 다른 것을 배우는 것

<hr/>

## 21. JSP 처리 과정(톰켓이 요청시)
1. 웹 브라우저가 jsp 파일을 요청
2. 웹 서버는 요청된 jsp 파일을 확인 후 웹 컨테이너로 전달
3. 웹 컨테이너는 JSP 파일을 서블릿 으로 변환 즉, .java 파일로 변환
4. 그후 컴파일하면 .class 파일이 나온다.
5. 다시 웹 서버로 전달하고 웹서버는 웹 브라우저에 HTML 형태로 전송한다.

<hr/>

## 22. IoC(Inversion of Control) 정의
인스턴스를 `제어하는 주도권이 역전`된다는 의미로 컴포넌트를 구성하는 __인스턴스 생성과 의존관계 연결__ 을 개발자 소스 코드가 아닌 __DI컨테이너가 대신__ 해 주기 때문에 제어가 역전 되었다고 한다.

<hr/>

## 23. IoC 컨테이너 정의
스프링 프레임워크가 제공하는 IoC컨테이너를 통해 인스턴스의 생명주기 관리 및 의존관계 주입을 처리한다.

<hr/>

## 24. IoC 컨테이너의 실체
일반적인 스프링 컨테이너이고 BeanFactory를 상속받은 하위 인터페이스인 ApplicationContext를 말한다.

<hr/>

## 25. 스프링 빈 정의
스프링 컨테이너가 관리하는 객체

<hr/>

## 26. WAC의 2가지(contextLoadListener, DispatcherServlet) 생성 과정을 설명
* WAC(Web Application Context): 웹 어플리케이션 컨텍스트
1. 웹 어플리케이션이 요청되면 __WAS__ 에 의해 __web.xml__ 이 로드 된다.
2. __web.xml__ 에 등록한 __`contextLoadListener`__ 가 생성되고 생성된 __contextLoadListener__ 는 __root-context.xml__ 을 로드한다.
3. __root-context.xml__ 에 등록된 __spring Container__ 가 구동 되고, 이때 개발자가 작성한 비즈니스 로직 DAO, VO 객체를 생성한다.
4. 클라이언트로부터 웹 어플리케이션이 요청이 오면 __`DispatcherServlet`__ 이 생성되고 __servlet-context.xml__ 을 로드한다. 
5. __servlet-context.xml__ 는 __FrontController__ 의 역할을 수행한다.
6. __FrontController__ 는 클라이언트로부터 요청 온 메시지를 분석하여 알맞은 __pageController__ 에게 전달하고 응답받아 요청에 따른 응답을 어떻게 할지 결정만 한다.

<hr/>

## 27. 자바 웹 어플리케이션 설계 방식 3가지 차이점
* __Model 1__ 
  + JSP만 사용하여 개발하거나 java bean을 포함하여 개발하는 방식이다.
  + 뷰와 비즈니스 로직이 혼재 되어 복잡도가 높고 유지보수가 어렵다
* __Model 2__ 
  + MVC로 분리하여 개발 하는 방식이다 뷰와 비즈니스 로직을 분리하여 유지보수하기 좋다.
* __프론트 컨트롤러__ 
  + __클라이언트 요청을 프론트 컨트롤러에 집중__ 시키고 프론트 컨트롤러가 들어온 url을 Handler Mapping을 통하여 판단하여 적절한 컨트롤러에 넘겨주는 MVC방식 이다.
  + 또한, 프론트 컨트롤러는 컨트롤러가 return하는 뷰 이름을 ViewResolver를 통해 뷰 이름에 해당하는 view(jsp)를 호출한다.

<hr/>

## 28. 다형성(Polymorphism)이란?
서로 다른 클래스로부터 만들어진 객체지만 같은 부모의 Class 타입으로 이들을 관리할 수 있는(=대입될 수 있는) 성질
* [다형성 예시 참고](https://asfirstalways.tistory.com/168)
### Wiki 정의
그 프로그래밍 언어의 자료형 체계의 성질을 나타내는 것으로, 프로그램 언어의 각 요소들(상수, 변수, 식, 오브젝트, 함수, 메소드 등)이 다양한 자료형(type)에 속하는 것이 허가되는 성질을 가리킨다.

<hr/>

## 29. 컬렉션프레임워크(CollectionFramework)에 대해 아는만큼 말해 보시오.
### Collection 인터페이스
1. __List 인터페이스__ : 배열과 유사하되, 추가할때마다 자동으로 Boundary를 늘려주는 구조로, 중복된 데이터를 허용하며, 순서가 존재한다.
   * ex) ArrayList : 배열로 구현됬으며, 인접해 있기 때문에 데이터 조회에 매우 빠르다 하지만, 빈번한 삽입, 삭제시 새로 배열을 만들고 데이터를 옮겨야 하기 때문에 LinkedList에 비하여 속도가 느리다.
   * ex) LinkedList : 링크 구조로 되어 있기 때문에 조회는 ArrayList에 비해 느리지만, 삽입 삭제시 링크를 끊고 새로 추가되는 데이터에 링크만 연결하면 되기 때문에 삽입, 삭제에 유리하다.
   * ex) Vector : 구현 방식은 ArrayList와 유사하지만 Vector를 개선한 것이 ArrayList이다. 또한 Vector의 경우에는 ArrayList와 달리 Synchronized(동기화)가 걸려 있어 여러 쓰레드에서 동시에 접근할 수 없다.

2. __Set 인터페이스__ : 집합처럼 중복된 데이터를 허용하지 않으며, 순서가 없다. 또한, 객체 내부의 중복된 데이터를 배제하고 싶은 경우 Object 클래스의 equals 메서드와 hashCode 메서드의 재정의가 반드시 필요하다.
   * ex) HashSet
   * ex) TreeSet : 순서가 있는 HashSet으로 이진 트리 구조로 만들어 졌다. 순서에 맞게 정렬되어 저장되기 위해서 Comparable을 구현해야한다.

3. __Map 인터페이스__ : key와 value 쌍으로 데이터를 저장하며, key는 중복될 수 없고, value는 중복 저장이 가능하다.
   * ex) HashMap
   * ex) TreeMap
   * ex) Properties : key value 쌍으로 저장되지만 value의 타입이 String만 가능하다.
   * ex) Hashtable : HashMap과 구조는 같으며, 단지 Synchronized(동기화) 되어져 있다는 점이 다른점이다.

<hr/>

## 30. 캐시(Cache)와 세션(Session)의 공통점과 차이점은?
### 공통점
  + 둘 다 사용자의 데이터를 저장한다.
  
### 차이점
  + __캐시:__ 캐시는 Client 컴퓨터에 저장했다 서버 요청시 네트워크를 타고 서버로 전달되기 때문에 보안에 취약하다.
  + __세션:__ 세션은 서버에 저장되고 브라우저 단위로 관리된다. 캐시에 비해 보안성이 좋다.

<hr/>

## 31.  프로세스(Process) 와 쓰레드(Thread)의 차이점에 대해 아는가?
### 프로세스
프로세스는 OS가 메모리 등의 자원을 할당해준 실행중인 프로그램을 가리킨다. 
이때, 각각의 프로세스는 서로 메모리 공간을 독자적으로 갖기 때문에 서로 메모리 공간을 공유하지 못한다. 
따라서, 공유하기 위해서는 IPC(InterProcess Communication)과 같은 방식이 필요하다.

### 쓰레드
쓰레드는 프로세스 내에서 프로세스의 자원을 가지고 실제로 일하는 "일꾼"과 같으며 각 쓰레드는 독자적인 Stack 메모리를 갖고 그 외의 자원(메모리)는 프로세스 내에서 공유하게 된다.

<hr/>

## 32. GC 매커니즘
더 이상 사용되지 않는 객체들은 `가비지 컬렉션`을 담당하는 프로세스가 자동으로 메모리에서 제거하도록 하는 것이 가비지 컬렉션의 기본 개념 이다.

자바는 `가비지 컬렉션`에 아주 단순한 규칙을 적용한다.

Heap 영역의 오브젝트 중 stack 에서 `도달 불가능한 (Unreachable) 오브젝트`들은 가비지 컬렉션의 대상이 된다.

otSpot VM에서는 크게 2개로 물리적 공간을 나누었다. 둘로 나눈 공간이 `Young 영역`과 `Old 영역`이다.

### Young 영역(Yong Generation 영역)
새롭게 생성한 객체의 대부분이 여기에 위치한다. 대부분의 객체가 금방 접근 불가능 상태가 되기 때문에 매우 많은 객체가 Young 영역에 생성되었다가 사라진다. 이 영역에서 객체가 사라질때 Minor GC가 발생한다고 말한다.
* Young 영역은 3개의 영역으로 나뉜다.
  + Eden 영역
  + Survivor 영역(2개)
### Old 영역(Old Generation 영역)
접근 불가능 상태로 되지 않아 Young 영역에서 살아남은 객체가 여기로 복사된다. 대부분 Young 영역보다 크게 할당하며, 크기가 큰 만큼 Young 영역보다 GC는 적게 발생한다. 이 영역에서 객체가 사라질 때 Major GC(혹은 Full GC)가 발생한다고 말한다.

### 영역의 처리 절차
__Eden 영역__ 에 최초로 객체가 만들어지고, Survivor 영역을 통해서 __Old 영역__ 으로 오래 살아남은 객체가 이동한다

<hr/>


<br/>
<br/>

내용 추가 예정...

<br/>
<br/>

<hr/>

# 알고리즘 인터뷰(Hand Write Coding)
* 알고리즘 인터뷰 가이드 1: 준비편
http://theyearlyprophet.com/interviews-101-preparation.html

# Reference
> * [basic-concepts-of-development-spring](https://gmlwjd9405.github.io/2017/10/01/basic-concepts-of-development-spring.html)
> * [webserver-vs-was](https://gmlwjd9405.github.io/2018/10/27/webserver-vs-was.html)
> * [https://bkim.tistory.com/13](https://bkim.tistory.com/13)
> * [tech-interview](https://github.com/WeareSoft/tech-interview/blob/master/contents/db.md#orm%EC%9D%B4%EB%9E%80)